import time
import os
import sys
import sqlite3
import hashlib
import subprocess
import yaml
import glob
import streamlit as st
from datetime import datetime
# Add root to path for script imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from scripts import ui_utils, config_utils, db_manager
from streamlit_code_diff import st_code_diff
from streamlit_monaco import st_monaco
import streamlit_antd_components as sac
from scripts.render_prompt import render_template

# Page Config
st.set_page_config(
    page_title="Git Diff RAG ‚Äî Review Cockpit",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# World-Class HMI Styling
st.markdown("""
<style>
    .main { background-color: #0d1117; color: #c9d1d9; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; }
    .stTabs [data-baseweb="tab-list"] { gap: 10px; }
    .stTabs [data-baseweb="tab"] { background-color: #161b22; border: 1px solid #30363d; border-radius: 6px 6px 0 0; color: #8b949e; padding: 10px 20px; }
    .stTabs [aria-selected="true"] { background-color: #0d1117; color: #58a6ff; border-bottom: 2px solid #58a6ff; }
    
    .hero-panel { background: #161b22; padding: 1.5rem; border-radius: 12px; border: 1px solid #30363d; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
    .finding-alert { padding: 12px; border-radius: 6px; margin-bottom: 8px; border-left: 5px solid; }
    .finding-high { background: rgba(248, 81, 79, 0.1); border-color: #f85149; color: #ff7b72; }
    .finding-med { background: rgba(210, 153, 34, 0.1); border-color: #d29922; color: #d29922; }
    
    .lego-block { background: #21262d; border: 1px solid #30363d; padding: 10px; border-radius: 6px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
    .lego-block:hover { border-color: #58a6ff; }
    .lego-tag { font-size: 0.7em; padding: 2px 6px; border-radius: 10px; background: #30363d; color: #8b949e; margin-right: 8px; }
    
    .status-bar { padding: 8px 20px; background: #161b22; border-top: 1px solid #30363d; position: fixed; bottom: 0; left: 0; width: 100%; color: #8b949e; z-index: 1000; font-family: monospace; font-size: 0.85em; }
    .hero-btn>button { background: linear-gradient(135deg, #1f6feb, #58a6ff) !important; color: white !important; height: 3.5rem !important; font-size: 1.2em !important; font-weight: 700 !important; border: none !important; border-radius: 8px !important; box-shadow: 0 4px 20px rgba(31, 111, 235, 0.4); transition: all 0.3s; }
    .hero-btn>button:hover { transform: translateY(-2px); box-shadow: 0 6px 25px rgba(31, 111, 235, 0.6); }
    .status-indicator { display: inline-block; padding: 4px 12px; background: #21262d; border: 1px solid #30363d; border-radius: 20px; font-size: 0.85em; color: #8b949e; margin-left: 10px; }
    .status-indicator.ready { border-color: #238636; color: #2ea043; }
    .compact-select { margin-bottom: 0.5rem; }
    /* Mermaid Styles Override */
    .mermaid { background: transparent !important; }
    .timer-badge { font-family: monospace; background: #30363d; color: #58a6ff; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
</style>
""", unsafe_allow_html=True)

# --- State Management ---
if 'repo' not in st.session_state: st.session_state.repo = None
if 'target' not in st.session_state: st.session_state.target = "main"
if 'source' not in st.session_state: st.session_state.source = "HEAD"
if 'target_commit' not in st.session_state: st.session_state.target_commit = None
if 'source_commit' not in st.session_state: st.session_state.source_commit = None
if 'active_bundle' not in st.session_state: st.session_state.active_bundle = []
if 'selected_file' not in st.session_state: st.session_state.selected_file = None
if 'agent_active' not in st.session_state: st.session_state.agent_active = False
if 'is_executing' not in st.session_state: st.session_state.is_executing = False
if 'current_step' not in st.session_state: st.session_state.current_step = None
if 'completed_steps' not in st.session_state: st.session_state.completed_steps = []
if 'execution_times' not in st.session_state: st.session_state.execution_times = {}
if 'show_advanced' not in st.session_state: st.session_state.show_advanced = False
if 'setup_complete' not in st.session_state: st.session_state.setup_complete = False

# --- Auto-Detection & Error Handling ---
repos = ui_utils.list_repositories()

# Auto-detect current repo if not set
if not st.session_state.repo:
    if repos:
        st.session_state.repo = repos[0]
        st.session_state.setup_complete = True
    else:
        st.session_state.setup_complete = False

if not st.session_state.setup_complete:
    # Show setup wizard
    st.error("‚ö†Ô∏è No repository configuration found")
    st.markdown("""
    ### Let's Get Started
    
    To use the Git Diff RAG Cockpit, you need to configure at least one repository.
    
    **Quick Setup:**
    1. Go to the **‚öôÔ∏è Settings** tab
    2. Click **"+ Add New"** under Repositories
    3. Fill in the repository details (name, path, main branch)
    4. Click **"üíæ Save Configuration"**
    
    **Need Help?** Check the [Setup Guide](../docs/COCKPIT.md) for detailed instructions.
    """)
    st.stop()

config = config_utils.load_repo_config(st.session_state.repo)
repo_path = config.get('path', '.') if config else '.'

# Validate repo path
try:
    result = subprocess.run(["git", "-C", repo_path, "rev-parse", "--git-dir"], 
                          capture_output=True, text=True, check=True)
    branches = ui_utils.get_branches(repo_path)
    
    # Auto-detect main branch if default doesn't exist
    if st.session_state.target not in branches:
        if "main" in branches:
            st.session_state.target = "main"
        elif "master" in branches:
            st.session_state.target = "master"
        elif branches:
            st.session_state.target = branches[0]
except (subprocess.CalledProcessError, FileNotFoundError):
    st.error(f"‚ö†Ô∏è Invalid repository path: `{repo_path}`")
    st.markdown("""
    The configured repository path is not a valid git repository.
    
    **To fix this:**
    1. Go to **‚öôÔ∏è Settings** tab
    2. Update the **Local Path** for `{}`
    3. Make sure it points to a valid git repository
    """.format(st.session_state.repo))
    st.stop()

# --- COMPACT TOP BAR ---
with st.container():
    col1, col2, col3, col4 = st.columns([2, 2, 2, 1])
    
    with col1:
        new_repo = st.selectbox("üì¶ Repository", options=repos, 
                               index=repos.index(st.session_state.repo) if st.session_state.repo in repos else 0,
                               key="repo_select")
        if new_repo != st.session_state.repo:
            st.session_state.repo = new_repo
            st.session_state.selected_file = None
            st.rerun()

    with col2:
        new_target = st.selectbox("üìç Compare Against", options=branches, 
                                 index=branches.index(st.session_state.target) if st.session_state.target in branches else 0,
                                 key="target_select")
        if new_target != st.session_state.target:
            st.session_state.target = new_target
            st.session_state.target_commit = None
            st.rerun()

    with col3:
        source_opts = ["Working Directory"] + branches
        new_source = st.selectbox("‚ú® Your Changes", options=source_opts, 
                                 index=source_opts.index(st.session_state.source) if st.session_state.source in source_opts else 0,
                                 key="source_select")
        if new_source != st.session_state.source:
            st.session_state.source = new_source
            st.session_state.source_commit = None
            st.rerun()
    
    with col4:
        if st.button("‚öôÔ∏è Advanced", use_container_width=True):
            st.session_state.show_advanced = not st.session_state.show_advanced
            st.rerun()

# Advanced Options (Collapsed by Default)
if st.session_state.show_advanced:
    with st.expander("üîß Advanced Options", expanded=True):
        adv_col1, adv_col2 = st.columns(2)
        
        with adv_col1:
            st.markdown("**Compare Against - Specific Commit**")
            target_commits = ui_utils.get_commits(repo_path, st.session_state.target)
            target_commit_opts = ["Current HEAD"] + [c['hash'] for c in target_commits]
            new_target_commit = st.selectbox("Target Commit", options=target_commit_opts, 
                                           index=0 if not st.session_state.target_commit else target_commit_opts.index(st.session_state.target_commit) if st.session_state.target_commit in target_commit_opts else 0, 
                                           label_visibility="collapsed",
                                           key="target_commit_select")
            st.session_state.target_commit = new_target_commit if new_target_commit != "Current HEAD" else None
        
        with adv_col2:
            if st.session_state.source != "Working Directory":
                st.markdown("**Your Changes - Specific Commit**")
                source_commits = ui_utils.get_commits(repo_path, st.session_state.source)
                source_commit_opts = ["Current HEAD"] + [c['hash'] for c in source_commits]
                new_source_commit = st.selectbox("Source Commit", options=source_commit_opts, 
                                               index=0 if not st.session_state.source_commit else source_commit_opts.index(st.session_state.source_commit) if st.session_state.source_commit in source_commit_opts else 0, 
                                               label_visibility="collapsed",
                                               key="source_commit_select")
                st.session_state.source_commit = new_source_commit if new_source_commit != "Current HEAD" else None
            else:
                st.session_state.source_commit = None

st.divider()

# Final Resolved Refs for Engine
actual_target, actual_source, _is_direct = ui_utils.get_smart_refs(repo_path, st.session_state.target, st.session_state.source, st.session_state.target_commit, st.session_state.source_commit)
changed_files = ui_utils.get_changed_files(repo_path, st.session_state.target, st.session_state.source, st.session_state.target_commit, st.session_state.source_commit)

if changed_files and not st.session_state.selected_file:
    st.session_state.selected_file = changed_files[0]

# Status Indicator
if changed_files:
    total_diff = ui_utils.get_diff(repo_path, actual_target, actual_source, target_commit=st.session_state.target_commit, source_commit=st.session_state.source_commit)
    lines_added = total_diff.count('\n+')
    lines_removed = total_diff.count('\n-')
    st.markdown(f'<span class="status-indicator ready">üü¢ {len(changed_files)} files changed (+{lines_added}, -{lines_removed} lines)</span>', unsafe_allow_html=True)
else:
    st.markdown('<span class="status-indicator">‚ö™ No changes detected</span>', unsafe_allow_html=True)

# --- MAIN LAYOUT ---
# Master Navigation Tabs (Simplified)
tab_review, tab_history, tab_editor, tab_settings = st.tabs(["üîç Review & Analyze", "üìú History", "üìù Editor", "‚öôÔ∏è Settings"])

# --- TAB 1: REVIEW & ANALYZE ---
with tab_review:
    # Hero Action Button (Top Right)
    action_col1, action_col2 = st.columns([3, 1])
    with action_col1:
        st.markdown("### üìù Code Changes")
    with action_col2:
        st.markdown('<div class="hero-btn">', unsafe_allow_html=True)
        if st.button("üöÄ RUN AI REVIEW", use_container_width=True, disabled=st.session_state.is_executing or not changed_files):
            if not st.session_state.active_bundle:
                # Use default bundle if none selected
                default_recipe = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                                            "prompts", "recipes", "standard_pr_review.md")
                if os.path.exists(default_recipe):
                    st.session_state.active_bundle = [default_recipe]
            
            if st.session_state.active_bundle:
                st.session_state.is_executing = True
                st.session_state.completed_steps = []
                st.session_state.execution_times = {}
                st.rerun()
        st.markdown('</div>', unsafe_allow_html=True)
    
    # Collapsible Prompt Customization
    with st.expander("üß± Customize Instructions (Advanced)", expanded=False):
        cust_col1, cust_col2 = st.columns([1, 2])
        
        with cust_col1:
            st.markdown("#### üìö Prompt Library")
            library = ui_utils.list_prompt_library()
            recipes = [p for p in library if "recipes" in p['full_path']]
            
            for r in recipes:
                is_active = r['full_path'] in st.session_state.active_bundle
                btn_label = f"‚úì {r['name']}" if is_active else f"‚ûï {r['name']}"
                if st.button(btn_label, key=f"rec_{r['name']}", use_container_width=True):
                    if is_active:
                        st.session_state.active_bundle.remove(r['full_path'])
                    else:
                        st.session_state.active_bundle.append(r['full_path'])
                    st.rerun()
        
        with cust_col2:
            st.markdown("#### üß± Active Bundle")
            if not st.session_state.active_bundle:
                st.info("No custom prompts selected. Default review will be used.")
            else:
                for block_path in st.session_state.active_bundle:
                    name = os.path.basename(block_path)
                    st.markdown(f'<div class="lego-block"><span>{name}</span></div>', unsafe_allow_html=True)
                if st.button("üóëÔ∏è Clear All", use_container_width=True):
                    st.session_state.active_bundle = []
                    st.rerun()
    
    # Tool Selection
    with st.expander("‚öôÔ∏è AI Tool Configuration", expanded=False):
        tool_col1, tool_col2 = st.columns(2)
        with tool_col1:
            tool_choice = st.selectbox("AI Provider", ["Gemini API", "GitHub Copilot CLI"])
        with tool_col2:
            default_models = ["gemini-2.0-flash-exp", "gemini-1.5-pro", "gemini-1.5-flash"]
            if 'available_models' not in st.session_state:
                st.session_state.available_models = default_models
            model_choice = st.selectbox("Model", st.session_state.available_models, index=0)
    
    st.divider()
    
    r_col1, r_col2 = st.columns([1, 3])
    
    with r_col1:
        st.markdown("### üìÇ Files")
        if changed_files:
            # Filter Input
            filter_text = st.text_input("Filter files", placeholder="e.g. .py", label_visibility="collapsed")
            
            # 1. Filter by text
            text_filtered = [f for f in changed_files if filter_text.lower() in f.lower()] if filter_text else changed_files
            
            # 2. Filter by content (remove identicals)
            final_files = []
            # We use a spinner because this might take a moment for many files
            with st.spinner("Verifying actual changes..."):
                for f in text_filtered:
                    b = ui_utils.get_file_content(repo_path, actual_target, f)
                    a = ui_utils.get_file_content(repo_path, actual_source, f)
                    if b != a:
                        final_files.append(f)
            
            if not final_files:
                st.success("No content changes detected (files may differ only by line endings).")

            # Build Tree Structure & Label Map
            tree_items = []
            label_map = {} # label -> full_path

            def get_unique_label(base_label):
                label = base_label
                counter = 0
                while label in label_map:
                    counter += 1
                    label = base_label + "\u200b" * counter
                return label

            def add_to_tree(nodes, parts, full_path):
                part = parts[0]
                is_file = len(parts) == 1
                
                # Find existing node (by visual label, ignoring ZWS for matching parent folders)
                existing_node = None
                for node in nodes:
                    # Strip ZWS to match folder names correctly
                    if node.label.rstrip('\u200b') == part and ((is_file and node.icon == 'file-code') or (not is_file and node.icon == 'folder')):
                        existing_node = node
                        break
                
                if existing_node:
                    if is_file:
                        pass
                    else:
                        add_to_tree(existing_node.children, parts[1:], full_path)
                else:
                    # Create new node
                    if is_file:
                        unique_label = get_unique_label(part)
                        new_node = sac.TreeItem(unique_label, icon='file-code')
                        nodes.append(new_node)
                        label_map[unique_label] = full_path
                    else:
                        # Folders also need unique labels in the map if we want to be safe, 
                        # but usually we don't select folders. 
                        # However, we need to store them in the tree.
                        # We don't add folders to label_map for file selection, 
                        # but we need to ensure their labels are unique in the tree if they are siblings?
                        # Actually, sibling folders with same name are impossible.
                        # So folder labels are unique among siblings.
                        new_node = sac.TreeItem(part, icon='folder', children=[])
                        nodes.append(new_node)
                        add_to_tree(new_node.children, parts[1:], full_path)

            for f in sorted(final_files):
                parts = f.split('/')
                add_to_tree(tree_items, parts, f)

            # Render SAC Tree
            selected_label = sac.tree(
                items=tree_items, 
                label='', 
                align='start', 
                size='sm', 
                show_line=True, 
                icon='folder',
                open_all=True,
                return_index=False, # Use labels
                key=f'file_tree_{filter_text}_{len(final_files)}'
            )
            
            # Handle Selection
            if selected_label:
                # sac returns a list if multiple, or string if single?
                # Documentation says: returns list of selected indexes or labels.
                # Wait, let's be safe.
                target_label = None
                if isinstance(selected_label, list) and len(selected_label) > 0:
                    target_label = selected_label[0]
                elif isinstance(selected_label, str):
                    target_label = selected_label
                
                if target_label and target_label in label_map:
                    full_path = label_map[target_label]
                    if full_path != st.session_state.selected_file:
                        st.session_state.selected_file = full_path
                        st.rerun()
                elif target_label:
                    # It might be a folder or unmapped item
                    pass
        else:
            st.success("No changes detected.")

    with r_col2:
        if st.session_state.selected_file:
            st.markdown(f"### üìù Diff: `{st.session_state.selected_file}`")
            st.caption(f"Comparing: `{actual_target}` ‚Üî `{actual_source}`")
            before = ui_utils.get_file_content(repo_path, actual_target, st.session_state.selected_file)
            after = ui_utils.get_file_content(repo_path, actual_source, st.session_state.selected_file)
            
            # Check if content is identical after normalization
            if before == after:
                st.info("File content is identical (ignoring line endings).")
                with st.expander("Show Content"):
                    st.code(after)
            else:
                st_code_diff(before, after)
            
            # Context Tower (Findings) moved here for relevance
            findings = ui_utils.get_findings(repo_path, actual_target, actual_source, st.session_state.target_commit, st.session_state.source_commit)
            if findings:
                with st.expander(f"üö® Rule Findings ({len(findings)})", expanded=False):
                    for f in findings:
                        sev = "high" if "security" in f['message'].lower() or "deprecated" in f['message'].lower() else "med"
                        st.markdown(f'<div class="finding-alert finding-{sev}"><b>{f["type"].upper()}</b>: {f["message"]}</div>', unsafe_allow_html=True)
        else:
            st.info("Select a file from the tree to view the diff.")
    
    # Execution Status (if running)
    if st.session_state.is_executing:
        st.divider()
        st.markdown("### üìä Analysis In Progress")
        
        with st.status("Running AI Review...", expanded=True) as status:
            try:
                # Execution logic (moved from Run Analysis tab)
                st.write("üì• Fetching diff...")
                diff_content = ui_utils.get_diff(repo_path, actual_target, actual_source, 
                                                target_commit=st.session_state.target_commit, 
                                                source_commit=st.session_state.source_commit)
                
                st.write("üß± Preparing prompt...")
                full_prompt = f"# CODE REVIEW REQUEST\n\n## DIFF\n\n```diff\n{diff_content}\n```\n\n"
                
                for p in st.session_state.active_bundle:
                    part = render_template(p, diff_content, repo_name=st.session_state.repo, inject_diff_content=False)
                    full_prompt += f"\n---\n\n{part}"
                
                timestamp = datetime.now().strftime("%Y%m%dT%H%M%S")
                out_folder = f"output/{timestamp}-{st.session_state.repo}-review"
                os.makedirs(out_folder, exist_ok=True)
                
                with open(f"{out_folder}/prompt.txt", "w") as f:
                    f.write(full_prompt)
                with open(f"{out_folder}/diff.patch", "w") as f:
                    f.write(diff_content)
                
                st.write(f"ü§ñ Calling {tool_choice}...")
                response = ""
                
                if tool_choice == "Gemini API":
                    from scripts import call_gemini
                    response = call_gemini.call_with_retry(full_prompt, model=model_choice)
                else:
                    from scripts import call_copilot_cli
                    response = call_copilot_cli.call_copilot(full_prompt, allow_tools=['shell(git)', 'write'], timeout=300)
                
                with open(f"{out_folder}/response.md", "w") as f:
                    f.write(response)
                
                st.write("üíæ Saving results...")
                db_manager.save_cache(
                    diff_hash=hashlib.md5(diff_content.encode()).hexdigest(),
                    prompt_hash=hashlib.md5(full_prompt.encode()).hexdigest(),
                    model=model_choice,
                    response=response,
                    repo_name=st.session_state.repo,
                    summary=response[:100] + "...",
                    tags="ui_review"
                )
                
                status.update(label="‚úÖ Analysis Complete!", state="complete", expanded=False)
                st.session_state.is_executing = False
                st.success(f"Review saved to `{out_folder}`")
                
                # Display results
                st.markdown("### üìã AI Review")
                st.markdown(response)
                
            except Exception as e:
                status.update(label="‚ùå Analysis Failed", state="error")
                st.error(f"Error: {e}")
                st.session_state.is_executing = False

# --- TAB 2: HISTORY ---

with tab_history:
    st.markdown("### üìú Execution History")
    
    ht_files, ht_db = st.tabs(["üìÇ File Output", "üóÑÔ∏è Database"])
    
    # --- SUB-TAB: FILES ---
    with ht_files:
        # Assuming output is in the root directory, one level up from cockpit/
        output_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "output")
        
        if os.path.exists(output_dir):
            runs = sorted([d for d in os.listdir(output_dir) if os.path.isdir(os.path.join(output_dir, d))], reverse=True)
            
            if runs:
                col_h1, col_h2 = st.columns([1, 3])
                with col_h1:
                    selected_run = st.radio("Select Run", runs, label_visibility="collapsed")
                
                with col_h2:
                    if selected_run:
                        run_path = os.path.join(output_dir, selected_run)
                        st.caption(f"Path: `{run_path}`")
                        
                        run_files = sorted(os.listdir(run_path))
                        tabs_files = st.tabs([f for f in run_files])
                        
                        for i, f_name in enumerate(run_files):
                            with tabs_files[i]:
                                file_path = os.path.join(run_path, f_name)
                                try:
                                    with open(file_path, "r") as f:
                                        content = f.read()
                                    
                                    if f_name.endswith(".json"):
                                        st.json(content)
                                    elif f_name.endswith(".md"):
                                        st.markdown(content)
                                        with st.expander("Source"):
                                            st.code(content, language="markdown")
                                    else:
                                        st.code(content)
                                except Exception as e:
                                    st.error(f"Error reading file: {e}")
            else:
                st.info("No runs found.")
        else:
            st.error(f"Output directory not found: {output_dir}")

    # --- SUB-TAB: DATABASE ---
    with ht_db:
        db_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "data", "history.sqlite")
        if os.path.exists(db_path):
            try:
                conn = sqlite3.connect(db_path)
                c = conn.cursor()
                c.execute("SELECT id, timestamp, repo_name, model, cost, summary, tags FROM analysis_history ORDER BY id DESC")
                rows = c.fetchall()
                cols = [description[0] for description in c.description]
                data = [dict(zip(cols, row)) for row in rows]
                conn.close()
                
                if data:
                    st.dataframe(data, use_container_width=True)
                else:
                    st.info("Database is empty.")
            except Exception as e:
                st.error(f"Error reading database: {e}")
        else:
            st.warning(f"Database not found at {db_path}")

# --- TAB 3: EDITOR ---
with tab_editor:
    st.markdown("### üìù Prompt Editor")
    
    e_col1, e_col2 = st.columns([1, 3])
    
    with e_col1:
        editor_mode = st.radio("Mode", ["Recipes", "Library"], horizontal=True)
        
        base_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "prompts")
        target_dir = os.path.join(base_path, "recipes") if editor_mode == "Recipes" else os.path.join(base_path, "library")
        
        if os.path.exists(target_dir):
            files = []
            for root, dirs, filenames in os.walk(target_dir):
                for filename in filenames:
                    if filename.endswith(".md"):
                        rel_path = os.path.relpath(os.path.join(root, filename), target_dir)
                        files.append(rel_path)
            files.sort()
            
            selected_edit_file = st.selectbox("Select File", files, index=0 if files else None)
        else:
            st.error(f"Directory not found: {target_dir}")
            selected_edit_file = None

    with e_col2:
        if selected_edit_file:
            full_edit_path = os.path.join(target_dir, selected_edit_file)
            
            with open(full_edit_path, "r") as f:
                content = f.read()
                
            new_content = st_monaco(value=content, height="600px", language="markdown")
            
            if st.button("üíæ Save Changes"):
                with open(full_edit_path, "w") as f:
                    f.write(new_content)
                st.success(f"Saved {selected_edit_file}")

# --- TAB 4: SETTINGS ---
with tab_settings:
    st.markdown("### ‚öôÔ∏è Repository Settings")
    
    s_col1, s_col2 = st.columns([1, 2])
    
    repo_setup_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "repository-setup")
    
    with s_col1:
        st.markdown("#### Repositories")
        existing_configs = [f.replace(".md", "") for f in os.listdir(repo_setup_dir) if f.endswith(".md") and f != "TEMPLATE.md"]
        existing_configs.sort()
        
        selected_config = st.selectbox("Select Repository", ["+ Add New"] + existing_configs)
        
    with s_col2:
        st.markdown("#### Configuration")
        
        if selected_config == "+ Add New":
            config_name = st.text_input("Repository Name (ID)", placeholder="my-new-repo")
            config_data = {}
            body_content = "# New Repository\n\nDescription here."
        else:
            config_name = selected_config
            full_config_path = os.path.join(repo_setup_dir, f"{selected_config}.md")
            
            with open(full_config_path, "r") as f:
                raw_content = f.read()
                
            if raw_content.startswith("---"):
                try:
                    _, frontmatter, body_content = raw_content.split("---", 2)
                    config_data = yaml.safe_load(frontmatter)
                except ValueError:
                    config_data = {}
                    body_content = raw_content
            else:
                config_data = {}
                body_content = raw_content

        # Form
        with st.form("repo_settings_form"):
            path = st.text_input("Local Path", value=config_data.get("path", ""))
            main_branch = st.text_input("Main Branch", value=config_data.get("main_branch", "main"))
            remote = st.text_input("Remote", value=config_data.get("remote", "origin"))
            
            # Workflows
            recipes_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "prompts", "recipes")
            available_recipes = [f.replace(".md", "") for f in os.listdir(recipes_dir) if f.endswith(".md")]
            
            current_workflows = config_data.get("workflows", [])
            if isinstance(current_workflows, dict):
                current_workflows = list(current_workflows.keys())
            elif not isinstance(current_workflows, list):
                current_workflows = []
                
            selected_workflows = st.multiselect("Enabled Workflows", available_recipes, default=[w for w in current_workflows if w in available_recipes])
            
            default_wf_opts = selected_workflows if selected_workflows else ["pr_review"]
            current_default = config_data.get("default_workflow", "pr_review")
            default_workflow = st.selectbox("Default Workflow", default_wf_opts, index=default_wf_opts.index(current_default) if current_default in default_wf_opts else 0)
            
            # Model
            current_model = "gemini-1.5-flash"
            if default_workflow in config_data and isinstance(config_data[default_workflow], dict):
                 current_model = config_data[default_workflow].get("model", "gemini-1.5-flash")
            
            model = st.text_input("Preferred Model", value=current_model)
            
            body_editor = st.text_area("Description / Notes (Markdown)", value=body_content.strip(), height=200)
            
            submitted = st.form_submit_button("üíæ Save Configuration")
            
            if submitted:
                if not config_name:
                    st.error("Repository Name is required.")
                else:
                    new_config = {
                        "path": path,
                        "main_branch": main_branch,
                        "remote": remote,
                        "default_workflow": default_workflow,
                        "workflows": selected_workflows
                    }
                    
                    # Add specific workflow configs
                    for wf in selected_workflows:
                        new_config[wf] = {
                            "prompt": f"prompts/recipes/{wf}.md",
                            "llm": "gemini",
                            "model": model
                        }
                    
                    if config_utils.save_repo_config(config_name, new_config, body_editor):
                        st.success(f"Saved configuration for {config_name}")
                        time.sleep(1)
                        st.rerun()



# --- STATUS ---
st.markdown(f"""
<div class="status-bar">
    READY | REPO: {st.session_state.repo} | TARGET: {actual_target} | SOURCE: {actual_source} | {datetime.now().strftime('%H:%M:%S')}
</div>
""", unsafe_allow_html=True)
